Sequences are data structures that can be iterated over eg. lists, tuples, dictionaries
list = [1,2,3,4] # mutable
list[0] # how to access
tuple = (1,'a',2,'b') #immutable
tuple[1]
dict = {'key':'value', 'key2':'value2'}
dict['key'] # access for all three through []
------------------------------------
Date/time modules

import datetime as dt
import time as tm
tm.time() # number of seconds since Jan 1, 1970 (epoch)
dtnow = dt.datetime.fromtimestamp(tm.time()) # converts time into year, month, day etc
#dtnow.year, dtnow.month, dtnow.day, dtnow.hour, dtnow.minute, dtnow.second etc.
dt.date.today() # shows today
dt.timedelta(days = 100) # create a timedelta of 100 days
dt.date.today() - dt.timedelta(days = 100) # the date 100 days befor today
------------------------------------
Basic OOP

#Class definition
class Person:
    department = 'School of Information' #a class variable

    def set_name(self, new_name): #a method
        self.name = new_name
    def set_location(self, new_location):
        self.location = new_location
        
#Object instantiation and use:
person = Person()
person.set_name('Sanjeev Pillai')
person.set_location('Bedford, MA')
print('{} live in {} and works in the department {}'.format(person.name, person.location, person.department))
------------------------------------
Map, functional programming
Funtional programming is where all parameters to a function are defined thus showing what can change and what can't. Often the parameters themselves can be functions.

#Map() lets you execute a function on a set of iterable data
store1 = [10.00, 11.00, 12.34, 2.34]
store2 = [9.00, 11.10, 12.34, 2.01]
map(min, store1, store2) # runs the min function comparing 2 lists and returns the min value at each position

for item in (map(min, store1, store2)):
    print(item)
------------------------------------
Lambda - python's way of creating anonymous functions
Usually evaluates only a single expression, so not suited for complex logic, but can effectively do simple data cleaning.

lambda a, b, c : a + b # takes 3 args and adds the first two. Parameters before the colon and expression after
returns a function expression that can be stored in a variable and called as follows:
myfunc = lambda a, b, c : a + b
myfunc(1,2,3) # will return 1+2
------------------------------------
List comprehension
Iterating through the elements of a sequence and doing some operation all in one statement without having to loop through
[<some operation on x> for x in <some sequence>] # returns a list, so need to be enclosed in []
[i^2 for i in range(10)] # returns the squares of numbers 1-10
------------------------------------
Numpy
Create a numpy array, also called nd array for n-dimensional array

npa = ndarray([1,2,3],[3,4,5],[6,7,8]) # creates a 3x3 matrix where each list is a row
npa.shape() # returns dimensions 
npa.reshape(x,y) # if npa is a one dimensional array, reshape turns it into a, x,y matrix
npa.resize(x,y) # changes dimensions of an existing matrix
np.ones((x,y)), np.zeros((x,y)), np.eye(4) # creates a matrix of ones, zeros, identity
npa.linspace(0,4,9) # take 9 equidistant values between 0 and 4

x*y # element-wise multiplication of 2 matrices of same dimensions
x.doy(y) # matrix multiplication
x.T # transpose
min(), max(), mean(), std() # other common functions
argmax(), argmin() # returns index of max and min vals respectively

when copying arrays, use np.copy() to avoid affecting the original array
enumerate(matrix) # iterates over a matrix row by row
zip(mat1, mat2, mat3) # iterates over mutliple matrices of same dim
------------------------------------
Pandas 
import pandas as pd

The 'series' is a basic pandas data structure, somewhere between a list and a dictionary. Single indexed column of data. Items are stored in an order and there are labels with which they can be retrieved.

list a = [1,2,3]
x=pd.series(list, index=['First','Second','Third']) # stores a list of 3 numbers and labels them, so they can be retrieved either by x[index] or x.label.

underneath, pandas stores data in a numpy typed array. Numbers are stored by default as float64, strings as object.
Dictionaries can also be converted to pandas Series, no need to label.

x.index # shows all the labels/indexes

To find out if a value is NaN use np.isnan(<value>), equality won't work.

x.iloc[index] # used to retrieve by index, same as x[index]
x.loc['label'] # used to retrieve by label, same as x

Vectorization: do an operation on all elements of a data structure without looping.
np.sum(x) # will calculate the sum of all elements in the series x without looping through them
much faster than looping 

%%timeit n=100 # will time an operation for 100 loops, can be used to check the time of execution of loop vs no-loop

y = x.append(<list>) # will create y adding a new list to x, but won't change x

DataFrame - signature pandas data structure, resembles a table, same as data.frame in R
df = pd.DataFrame([series1, series2, series3])

df.loc[rowname, colname] # will pull out the value in that cell
df.loc[:,[col1, col2]] # pulls out all rows for the 2 cols mentioned
df.drop(row) # won't drop the row from the original df, only it is a df.copy()
copy_del(col) # will drop 
del copy_df[col] # will delete the column

df = pd.read_csv(<csv file>, index_col=0, skiprows=1) # read a csv file, skip the first row and use the first col as index

columns can be rename
df.columns - gives list of columns 
df.rename(col, inplace=True)

Querying a DataFrame:
By creating boolean arrays
df[col] > 0 # will create a boolean array where every entry that satisfies the condition will be true and the rest false. This array can be super-imposed on the dataframe to query with the 'where' clause:

df.where(df[col] > 0) # same as in R
df[df[col]>0] # same as above

Indexing DataFrames:
Any column can be used to index a dataframe
df = df.set_index(col) or df.set_index([list of cols])
df = df.reset_index() # will reset index

df[col].unique() # unique values from a col
df = df[df[col] == <some value>] # recreates the data frame with only those entries that satisfy the condition
df = df[<list of cols to keep>] # edits dataframe to drop all other cols

Missing values:
df.fillna(method = 'ffill')
