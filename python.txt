Sequences are data structures that can be iterated over eg. lists, tuples, dictionaries
list = [1,2,3,4] # mutable
list[0] # how to access
tuple = (1,'a',2,'b') #immutable
tuple[1]
dict = {'key':'value', 'key2':'value2'}
dict['key'] # access for all three through []

len(list) # gives length of list
------------------------------------
Date/time modules

import datetime as dt
import time as tm
tm.time() # number of seconds since Jan 1, 1970 (epoch)
dtnow = dt.datetime.fromtimestamp(tm.time()) # converts time into year, month, day etc
#dtnow.year, dtnow.month, dtnow.day, dtnow.hour, dtnow.minute, dtnow.second etc.
dt.date.today() # shows today
dt.timedelta(days = 100) # create a timedelta of 100 days
dt.date.today() - dt.timedelta(days = 100) # the date 100 days befor today
------------------------------------
Basic OOP

#Class definition
class Person:
    department = 'School of Information' #a class variable

    def set_name(self, new_name): #a method
        self.name = new_name
    def set_location(self, new_location):
        self.location = new_location
        
#Object instantiation and use:
person = Person()
person.set_name('Sanjeev Pillai')
person.set_location('Bedford, MA')
print('{} live in {} and works in the department {}'.format(person.name, person.location, person.department))
------------------------------------
Map, functional programming
Funtional programming is where all parameters to a function are defined thus showing what can change and what can't. Often the parameters themselves can be functions.

#Map() lets you execute a function on a set of iterable data
store1 = [10.00, 11.00, 12.34, 2.34]
store2 = [9.00, 11.10, 12.34, 2.01]
map(min, store1, store2) # runs the min function comparing 2 lists and returns the min value at each position

for item in (map(min, store1, store2)):
    print(item)
------------------------------------
Lambda - python's way of creating anonymous functions
Usually evaluates only a single expression, so not suited for complex logic, but can effectively do simple data cleaning.

lambda a, b, c : a + b # takes 3 args and adds the first two. Parameters before the colon and expression after
returns a function expression that can be stored in a variable and called as follows:
myfunc = lambda a, b, c : a + b
myfunc(1,2,3) # will return 1+2
------------------------------------
List comprehension
Iterating through the elements of a sequence and doing some operation all in one statement without having to loop through
[<some operation on x> for x in <some sequence>] # returns a list, so need to be enclosed in []
[i^2 for i in range(10)] # returns the squares of numbers 1-10
------------------------------------
iterating through multiple lists
for i,j in zip(list1, list2)
# fire up a jupyter notebbok
cd <desired directory>
jupyter notebook

# have jupyter linked to different versions of python
install Jupyter again using pip3 install jupyter
install Python3 kernel using jupyter kernelspec install-self

# have jupyter open in a browser you want
jupyter notebook --generate-config
vi ~/.jupyter/jupyter_notebook_config.py
#and change
c.NotebookApp.browser = ''
#to for example:
c.NotebookApp.browser = '/usr/bin/google-chrome'

------------------------------------
Virtualenv:
Create a virtual env with system packages
$ virtualenv --system-site-packages targetDirectory
Create a plain virtual env without system packages
$ virtualenv targetDirectory

Activate
$ source targetDirectory/bin/activate
Then pip install modules needed. This creates a self-contained installation that can be used to create an app
To deactivate
(targetDirectory)$ deactivate

You can also modules by
$ targetDirectory/bin/pip install <packagename>
------------------------------------

%%timeit n=100 # will time an operation for 100 loops, can be used to check the time of execution of loop vs no-loop


-----------------------------
groupby
when you have a data frame and want to group by a certain column, you can either loop through the data frame or use groupby (much faster)

while groupby(col) is standard, groupby can also take a function arugument. The function could be something that categorizes based on some complex criteria (not just col name)

The output from groupby can be passed on to the agg (aggregate) function to aggregate based on the result of the grouping

df.groupby('col1').agg({'col2': np.average}) # groups by the first column and then calculates the avg value for col2.

groupby can work at dataframe and series level. At dataframe level it can take multiple columns as arguments and it will run the aggregate separately for each column. It is also possible to aggregate based on different functions for the diff cols - for eg. avg for one column and sum for another.

groupby is very powerful, useful and popular
-----------------------------
Scales - 4 main categories
Ratio (mathematical operations like + and * are valid)
Interval (equally spaced units)
Ordinal (shows some type of order)
Nominal (no order)

df[col].astype('category') will transform that col into the category scale if the indexes refer to categories
astype('category', categories=<list of values>, ordered=True) # ordered = True makes the categories ordinal

Once converted to categorical, a df can be queried based on the category. For eg. >= 'C' if the categories are A,B,C,D and ordered.

pd.cut - divides a column into a specified number of bins
-----------------------------
pd.pivot_table() allows you to pivot your table and summarize/view data the way you want

df.pivot_table(values = <col which we want to summarize>, index = <col to be rows in the result>, columns = <cols of pivot table>, aggfunc = [<one or more list of func]) 

If a list of functions are passed, say min and max, the pivot table will show two column sets for the 2 funcs.

Time functions
pd.Timestamp() # converts an input like 10/12/2017 to a standard yyyy/mm/dd format
pd.Period() # converts input into a period eg. 01/2017 will be converted to a month period and 01/01/2017 to day

DateTimeIndex, PerodIndex - refers to indexes that are DateTime(Timestamp) or Period

pd.to_datetime() # converts input into Timestamp

Timestamps can be added to or subtracted from each other and it gives a Timedelta type. Similarly adding or subtracting Timestamp and Timedelta gives Timestamp. Timedelta is a certain interval of time eg. 12D or 13H

pd.date_range() # creates a date range just like a sequence with intervals etc.
-----------------------------
Plotting with matplotlib
import matplotlib.pyplot as plt
plt.plot(x,y) # x and y are lists to display in x and y axis
plt.hist(x, bins=<#bins>) # x is a list of values

To actually display the plot after all customizations:
plt.show()

labeling axes:
plt.xlabel('blah')
plt.ylabel('blah')
plt.title('blah')
plt.yticks([1,2,3,4],['a','b','c','d']) # defines y ticks and labels to shows (second list should match length of first)

plt.xscale('log') # converts x-axis to log scale

plt.scatter(x,y, s=<list with same length as x/y>, c = <list with colors>, alpha=0.8) # makes the scatter size based, s meaning size, c is for color and alpha for opacity value

plt.txt(<x coord>, <y coord>, 'text to display') # displays text in the plot
