A version control system is a tool that manages changes made to the files and directories in a project. Git can synchronize work done by different people on different machines, so it scales as your team does. Version control isn't just for software: books, papers, parameter sets, and anything that changes over time or needs to be shared can and should be stored and shared using something like Git.

Each of your Git projects has two parts: the files and directories that you create and edit directly, and the extra information that Git records about the project's history. The combination of these two things is called a repository. Git stores all of its extra information in a directory called .git located in the root directory of the repository. Git expects this information to be laid out in a very precise way, so you should never edit or delete anything in .git

When you are using Git, you will frequently want to check the status of your repository. To do this, run the command 'git status', which displays a list of the files that have been modified since the last time changes were saved.

Git has a staging area in which it stores files with changes you want to save that haven't been saved yet. Putting files in the staging area is like putting things in a box, while committing those changes is like putting that box in the mail: you can add more things to the box or take things out as often as you want, but once you put it in the mail, you can't make further changes.

'git status' shows you which files are in this staging area, and which files have changes that haven't yet been put there. In order to compare the file as it currently is to what you last saved, you can use 'git diff filename'. git diff without any filenames will show you all the changes in your repository, while git diff directory will show you the changes to the files in some directory.

A diff is a formatted display of the differences between two sets of files. Git displays diffs like this:

diff --git a/report.txt b/report.txt
index e713b17..4c0742a 100644
--- a/report.txt
+++ b/report.txt
@@ -1,4 +1,4 @@
-# Seasonal Dental Surgeries 2017-18
+# Seasonal Dental Surgeries (2017) 2017-18

 TODO: write executive summary.
This shows:

The command used to produce the output (in this case, diff --git). In it, a and b are placeholders meaning "the first version" and "the second version".
An index line showing keys into Git's internal database of changes. We will explore these in the next chapter.
--- a/report.txt and +++ b/report.txt, which indicate that lines being removed are prefixed with -, while lines being added are prefixed with +.
A line starting with @@ that tells where the changes are being made. Here, the line shows that lines 1-4 are being removed and replaced with new lines.
A line-by-line listing of the changes with - showing deletions and + showing additions. (We have also configured Git to show deletions in red and additions in green.) Lines that haven't changed are sometimes shown before and after the ones that have in order to give context; when they appear, they don't have either + or - in front of them.

Desktop programming tools like RStudio can turn diffs like this into a more readable side-by-side display of changes; you can also use standalone tools like DiffMerge or WinMerge.
----------------------------------------
What's the first step in saving changes?

You commit changes to a Git repository in two steps:
1) Add one or more files to the staging area.
2) Commit everything in the staging area.
To add a file to the staging area, use git add filename
To commit a file in the staging area, use git commit filename
Above two steps can be combined in one
git commit -a filename # will add and then commit file

git status shows what files in the repository have changed since the last commit and which of them have been staged (done 'git add' on)
----------------------------------------
How can I tell what's going to be committed?

To compare a file's current state to the changes in the staging area, you can use 
git diff -r HEAD path/to/file. 
The -r flag means "compare to a particular revision", HEAD is a shortcut meaning "the most recent commit", and the path to the file is the relative to where you are (for example, the path from the root directory of the repository). 
----------------------------------------
How can I view a repository's history?
The command 'git log' is used to view the log of the project's history. Log entries are shown most recent first, and look like this:

commit 0430705487381195993bac9c21512ccfb511056d
Author: Rep Loop <repl@datacamp.com>
Date:   Wed Sep 20 13:42:26 2017 +0000

    Added year to report title.

The commit line displays a unique ID for the commit called a hash; we will explore these further in the next chapter. The other lines tell you who made the change, when, and what log message they wrote for the change.

In the 'git log' output the first lines show the latest commit, the last lines show the first commit.
----------------------------------------
How can I view a specific file's history?
A project's entire log can be overwhelming, so it's often useful to inspect only the changes to particular files or directories. 

You can do this using 'git log <path>', where path is the path to a specific file or directory. The log for a file shows changes made to that file; the log for a directory shows when files were added or deleted in that directory, rather than when the contents of the directory's files were changed.
----------------------------------------
How does Git store information?
In order to make common operations fast and minimize storage space, Git uses a multi-level structure to store data. In simplified form, this has three key parts:

Every unique version of every file. (Git calls these blobs because they can contain data of any kind.)
A tree that tracks the names and locations of a set of files.
A commit that records the author, log message, and other properties of a particular commit.
----------------------------------------
What is a hash?
Every commit to a repository has a unique identifier called a hash (since it is generated by running the changes through a pseudo-random number generator called a hash function). This hash is normally written as a 40-character hexadecimal string like 7c35a3ce607a14953f070f0f83b5d74c2296ef93, but most of the time, you only have to give Git the first 6 or 8 characters in order to identify the commit you mean.

Hashes are what enable Git to share data efficiently between repositories. If two files are the same, their hashes are guaranteed to be the same. Similarly, if two commits contain the same files and have the same ancestors, their hashes will be the same as well. Git can therefore tell what information needs to be saved where by comparing hashes rather than comparing entire files.
----------------------------------------


----------------------------------------


Create local repository:
1) In directory with the files to commit run 'git init'
2) 'git add <filename(s)>' will add the files and stage them for commit
3) 'git commit -m <"some message">' # will commit all the files

Remote repository
1) log into github.com (or any other) and create a new repository using the GUI
2) then come back to local repository directory and run 'git remote add origin git@github.com:spillai2/reponame'. This will link your local to remote
3) 'git push' will push your commits to remote
4) 'git pull' will pull in changes from remote to local
----------------------------------------
